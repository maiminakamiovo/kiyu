<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0059)http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>
      FrontendNameConvention – Labway LIMS
    </title>
      
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!--[if IE]><script type="text/javascript">
      if (/^#__msie303:/.test(window.location.hash))
        window.location.replace(window.location.hash.replace(/^#__msie303:/, '#'));
    </script><![endif]-->
          <link rel="search" href="http://10.1.0.6/trac/LabwayLIMS/search">
          <link rel="help" href="http://10.1.0.6/trac/LabwayLIMS/wiki/TracGuide">
          <link rel="alternate" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention?format=txt" type="text/x-trac-wiki" title="纯文本">
          <link rel="tracwysiwyg.base" href="http://10.1.0.6/trac/LabwayLIMS">
          <link rel="start" href="http://10.1.0.6/trac/LabwayLIMS/wiki">
          <link rel="stylesheet" href="./FrontendNameConvention – Labway LIMS_files/trac.css" type="text/css">
          <link rel="stylesheet" href="./FrontendNameConvention – Labway LIMS_files/wiki.css" type="text/css">
          <link rel="stylesheet" href="./FrontendNameConvention – Labway LIMS_files/wysiwyg.css" type="text/css">
          <link rel="tracwysiwyg.stylesheet" href="./FrontendNameConvention – Labway LIMS_files/trac.css">
          <link rel="tracwysiwyg.stylesheet" href="http://10.1.0.6/trac/LabwayLIMS/chrome/tracwysiwyg/editor.css">
          <link rel="icon" href="http://10.1.0.6/trac/LabwayLIMS/chrome/common/trac.ico" type="image/x-icon">
    
      <link type="application/opensearchdescription+xml" rel="search" href="http://10.1.0.6/trac/LabwayLIMS/search/opensearch" title="搜索 Labway LIMS">
    <script type="text/javascript">
      var _tracwysiwyg={};
    </script>
      <script type="text/javascript" charset="utf-8" src="./FrontendNameConvention – Labway LIMS_files/jquery.js"></script>
      <script type="text/javascript" charset="utf-8" src="./FrontendNameConvention – Labway LIMS_files/babel.js"></script>
      <script type="text/javascript" charset="utf-8" src="./FrontendNameConvention – Labway LIMS_files/zh_CN.js"></script>
      <script type="text/javascript" charset="utf-8" src="./FrontendNameConvention – Labway LIMS_files/trac.js"></script>
      <script type="text/javascript" charset="utf-8" src="./FrontendNameConvention – Labway LIMS_files/search.js"></script>
      <script type="text/javascript" charset="utf-8" src="./FrontendNameConvention – Labway LIMS_files/folding.js"></script>
      <script type="text/javascript" charset="utf-8" src="./FrontendNameConvention – Labway LIMS_files/wysiwyg.js"></script>
    <script type="text/javascript">
      jQuery("#trac-noscript").remove();
      jQuery(document).ready(function($) {
        $(".trac-autofocus").focus();
        $(".trac-target-new").attr("target", "_blank");
        if ($.ui) { /* is jquery-ui added? */
          $(".trac-datepicker:not([readonly])").prop("autocomplete", "off").datepicker();
          $(".trac-datetimepicker:not([readonly])").prop("autocomplete", "off").datetimepicker();
          $("#main").addClass("trac-nodatetimehint");
        }
        $(".trac-disable").disableSubmit(".trac-disable-determinant");
        setTimeout(function() { $(".trac-scroll").scrollToTop() }, 1);
        $(".trac-disable-on-submit").disableOnSubmit();
      });
    </script>
    <link rel="alternate" type="application/x-wiki" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention?action=edit" title="编辑此页面">
    <script type="text/javascript">
      jQuery(document).ready(function($) {
        $("#content").find("h1,h2,h3,h4,h5,h6").addAnchor(_("Link to this section"));
        $("#content").find(".wikianchor").each(function() {
          $(this).addAnchor(babel.format(_("Link to #%(id)s"), {id: $(this).attr('id')}));
        });
        $(".foldable").enableFolding(true, true);
      });
    </script>
  </head>
  <body>
    <div id="banner">
      <div id="header">
        <a id="logo" href="http://10.1.0.6/trac/LabwayLIMS/"><img src="./FrontendNameConvention – Labway LIMS_files/labwaylims_logo.png" alt="Labway Laboratory Information Management System" height="46" width="178"></a>
      </div>
      <form id="search" action="http://10.1.0.6/trac/LabwayLIMS/search" method="get">
        <div>
          <label for="proj-search">搜索:</label>
          <input type="text" id="proj-search" name="q" size="18" value="">
          <input type="submit" value="搜索">
        </div>
      </form>
      <div id="metanav" class="nav">
    <ul>
      <li class="first">登录为 <span class="trac-author-user">王茹</span></li><li><form action="http://10.1.0.6/trac/LabwayLIMS/logout" class="trac-logout" id="logout" method="post"><div><input type="hidden" name="__FORM_TOKEN" value="c54acb6a9448c122699bab84"></div><div><button type="submit" name="logout">注销</button></div></form></li><li><a href="http://10.1.0.6/trac/LabwayLIMS/prefs">个人设置</a></li><li><a href="http://10.1.0.6/trac/LabwayLIMS/wiki/TracGuide">帮助/指南</a></li><li class="last"><a href="http://10.1.0.6/trac/LabwayLIMS/about">关于Trac</a></li>
    </ul>
  </div>
    </div>
    <div id="mainnav" class="nav">
    <ul>
      <li class="first active"><a href="http://10.1.0.6/trac/LabwayLIMS/wiki">Wiki</a></li><li><a href="http://10.1.0.6/trac/LabwayLIMS/timeline">时间线</a></li><li><a href="http://10.1.0.6/trac/LabwayLIMS/roadmap">路线图</a></li><li><a href="http://10.1.0.6/trac/LabwayLIMS/browser">源码浏览</a></li><li><a href="http://10.1.0.6/trac/LabwayLIMS/report">查看任务单</a></li><li><a href="http://10.1.0.6/trac/LabwayLIMS/newticket">新建任务单</a></li><li class="last"><a href="http://10.1.0.6/trac/LabwayLIMS/search">搜索</a></li>
    </ul>
  </div>
    <div id="main">
      <div id="pagepath" class="noprint">
  <a class="pathentry first" title="查看 WikiStart" href="http://10.1.0.6/trac/LabwayLIMS/wiki">wiki</a><a class="pathentry" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention" title="查看 FrontendNameConvention">FrontendNameConvention</a>
</div>
      <div id="ctxtnav" class="nav">
        <h2>上下文导航</h2>
        <ul>
          <li class="first"><a href="http://10.1.0.6/trac/LabwayLIMS/wiki/WikiStart">起始页</a></li><li><a href="http://10.1.0.6/trac/LabwayLIMS/wiki/TitleIndex">索引</a></li><li class="last"><a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention?action=history">历史</a></li>
        </ul>
        <hr>
      </div>
    <div id="content" class="wiki">
      <div class="wikipage searchable">
        
          <div id="wikipage" class="trac-content"><p>
</p><div class="wiki-toc">
<ol>
  <li>
    <ol>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#%E6%80%BB%E8%BF%B0">总述</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC">1. 代码风格</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.1%E6%96%87%E4%BB%B6">1.1 文件</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.2%E7%BB%93%E6%9E%84">1.2 结构</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.2.1%E7%BC%A9%E8%BF%9B">1.2.1 缩进</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.2.2%E7%A9%BA%E6%A0%BC">1.2.2 空格</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.2.3%E6%8D%A2%E8%A1%8C">1.2.3 换行</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.2.4%E8%AF%AD%E5%8F%A5">1.2.4 语句</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.3%E5%91%BD%E5%90%8D">1.3 命名</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.4%E6%B3%A8%E9%87%8A">1.4 注释</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.4.1%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A">1.4.1 单行注释</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.4.2%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A">1.4.2 多行注释</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.4.3%E6%96%87%E6%A1%A3%E5%8C%96%E6%B3%A8%E9%87%8A">1.4.3 文档化注释</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.4.4%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89">1.4.4 类型定义</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.4.5%E6%96%87%E4%BB%B6%E6%B3%A8%E9%87%8A">1.4.5 文件注释</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.4.6%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95%E6%B3%A8%E9%87%8A">1.4.6 函数/方法注释</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.4.7%E4%BA%8B%E4%BB%B6%E6%B3%A8%E9%87%8A">1.4.7 事件注释</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.4.8%E7%BB%86%E8%8A%82%E6%B3%A8%E9%87%8A">1.4.8 细节注释</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7">2 语言特性</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.1%E5%8F%98%E9%87%8F">2.1 变量</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.2%E6%9D%A1%E4%BB%B6">2.2 条件</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.3%E5%BE%AA%E7%8E%AF">2.3 循环</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.4%E7%B1%BB%E5%9E%8B">2.4 类型</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.4.1%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B">2.4.1 类型检测</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.4.2%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">2.4.2 类型转换</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.5%E5%AD%97%E7%AC%A6%E4%B8%B2">2.5 字符串</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.6%E5%AF%B9%E8%B1%A1">2.6 对象</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.7%E6%95%B0%E7%BB%84">2.7 数组</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.8%E5%87%BD%E6%95%B0">2.8 函数</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.8.1%E5%87%BD%E6%95%B0%E9%95%BF%E5%BA%A6">2.8.1 函数长度</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.8.2%E5%8F%82%E6%95%B0%E8%AE%BE%E8%AE%A1">2.8.2 参数设计</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.8.3%E9%97%AD%E5%8C%85">2.8.3 闭包</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.9%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">2.9 面向对象</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.10%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7">2.10 动态特性</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.10.1delete">2.10.1 delete</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.10.2%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">2.10.2 对象属性</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83">3 浏览器环境</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a3.1DOM">3.1 DOM</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a3.1.1%E5%85%83%E7%B4%A0%E8%8E%B7%E5%8F%96">3.1.1 元素获取</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a3.1.2%E6%A0%B7%E5%BC%8F%E8%8E%B7%E5%8F%96">3.1.2 样式获取</a>
      </li>
      <li>
        <a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a3.1.3%E6%A0%B7%E5%BC%8F%E8%AE%BE%E7%BD%AE">3.1.3 样式设置</a>
      </li>
    </ol>
  </li>
</ol>
</div><p>
</p>
<h2 id="总述">总述<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#%E6%80%BB%E8%BF%B0" title="链接到这一节"> ¶</a></h2>
<p>
本文档是前端开发的代码和命名规范，是公司“开发和代码的命名规范”的重要组成部分，是先有的<a class="wiki" href="http://10.1.0.6/trac/LabwayLIMS/wiki/NameConvention">代码和命名规范 (code and name convention)</a>的补充。
</p>
<h2 id="a1.代码风格">1. 代码风格<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC" title="链接到这一节"> ¶</a></h2>
<h2 id="a1.1文件">1.1 文件<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.1%E6%96%87%E4%BB%B6" title="链接到这一节"> ¶</a></h2>
<p>
[建议] JavaScript&nbsp;文件使用无&nbsp;BOM&nbsp;的&nbsp;UTF-8&nbsp;编码。<br>
</p>
<h2 id="a1.2结构">1.2 结构<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.2%E7%BB%93%E6%9E%84" title="链接到这一节"> ¶</a></h2>
<h2 id="a1.2.1缩进">1.2.1 缩进<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.2.1%E7%BC%A9%E8%BF%9B" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[强制] 使用&nbsp;4&nbsp;个空格做为一个缩进层级，不允许使用&nbsp;2&nbsp;个空格 或&nbsp;tab&nbsp;字符。</strong><br>
<strong>[强制]&nbsp;switch&nbsp;下的&nbsp;case&nbsp;和&nbsp;default&nbsp;必须增加一个缩进层级。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">// good
switch (variable) {
    case '1':
        // do...
        break;
    case '2':
        // do...
        break;
    default:
        // do...
}

// bad
switch (variable) {
case '1':
// do...
break;
case '2':
// do...
break;
default:
// do...
}

</pre><p>
<strong>[强制]组件内部属性名对应的"={}"前后不需要加空格；属性对齐方式，属性若能在一行中显示, 直接写成一行，若有多行属性,属性按四个空格进行缩进: </strong><br>
</p>
<pre class="wiki">&lt;Button 
    type="primary" 
    htmlType="submit" 
    size="default" 
    loading={this.state.loading} 
    onClick={this.handleSubmit.bind(this,true)} /&gt;
</pre><h2 id="a1.2.2空格">1.2.2 空格<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.2.2%E7%A9%BA%E6%A0%BC" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[强制] 二元运算符两侧必须有一个空格，一元运算符与操作对象之间不允许有空格。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">let a = !arr.length;
a++;
a = b + c;
</pre><p>
<strong>[强制] 用作代码块起始的左花括号&nbsp;{&nbsp;前必须有一个空格。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">// good
if (condition) {
}

while (condition) {
}

function funcName() {
}

funcName() {
}

// bad
if (condition){
}

while (condition){
}

function funcName(){
}

funcName(){
}

</pre><p>
<strong>[强制]&nbsp;if / else / for / while / function / switch / do / try / catch / finally 等关键字后，必须有一个空格。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">// good
if (condition) {
}

while (condition) {
}

(function () {
})();

// bad
if(condition) {
}

while(condition) {
}

(function() {
})();

</pre><p>
<strong> [强制] 在对象创建时，属性中的&nbsp;:&nbsp;之后必须有空格，:&nbsp;之前不允许有空格。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">// good
var obj = {
    a: 1,
    b: 2,
    c: 3
};

this.state = {
tableData: [],
loading: false
};

// bad
var obj = {
a : 1,
b:2,
c :3
};

this.state = {
tableData : [],
loading : false
};

</pre><p>
<strong>[强制] 函数声明、具名函数表达式、函数调用中，函数名和&nbsp;(&nbsp;之间不允许有空格。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">// good
function funcName() {
}

var funcName = function funcName() {
};

funcName();

render() {
};

constructor() {
}

componentDidMount() {
}

// bad
function funcName () {
}

var funcName = function funcName () {
};

funcName ();

render () {
};

constructor () {
}

componentDidMount () {
}

</pre><p>
<strong>[强制]&nbsp;,&nbsp;和&nbsp;;&nbsp;前不允许有空格。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">// good
callFunc(a, b);

// bad
callFunc(a , b) ;

</pre><p>
<strong>[强制] 在函数调用、函数声明、括号表达式、属性访问、if / for / while / switch / catch&nbsp;/ setState等语句中，()&nbsp;和&nbsp;[]&nbsp;内紧贴括号部分不允许有空格。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">// good

callFunc(param1, param2, param3);

save(this.list[this.indexes[i]]);

needIncream &amp;&amp; (variable += increament);

if (num &gt; list.length) {
}

while (len--) {
}

this.setState({
… …
});

// bad

callFunc( param1, param2, param3 );

save( this.list[ this.indexes[ i ] ] );

needIncreament &amp;&amp; ( variable += increament );

if ( num &gt; list.length ) {
}

while ( len-- ) {
}

this.setState( {
… …
} );

</pre><p>
<strong>[强制] 单行声明的数组与对象，如果包含元素，{}&nbsp;和&nbsp;[]&nbsp;内紧贴括号部分不允许包含空格。</strong><br>
解释：<br>
声明包含元素的数组与对象，只有当内部元素的形式较为简单时，才允许写在一行。元素复杂的情况，还是应该换行书写。<br>
</p>
<p>
示例：<br>
</p>
<pre class="wiki">// good
var arr1 = [];
var arr2 = [1, 2, 3];
var obj1 = {};
var obj2 = {name: 'obj'};
var obj3 = {
    name: 'obj',
    age: 20,
    sex: 1
}; 
this.setState({dataSource: tableData}); 
this.setState({
dataSource: tableData,
currentIndex: 1,
cardTitle: '测试标题'
});
const {fire, fault} = this.state;

// bad
var arr1 = [ ];
var arr2 = [ 1, 2, 3 ];
var obj1 = { };
var obj2 = { name: 'obj' };
var obj3 = {name: 'obj', age: 20, sex: 1};
this.setState({ dataSource: tableData });
this.setState({dataSource: tableData, index: 1, cardTitle: '测试标题'});
const { fire, fault } = this.state;

</pre><p>
<strong>[强制] 行尾不得有多余的空格。</strong>
</p>
<h2 id="a1.2.3换行">1.2.3 换行<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.2.3%E6%8D%A2%E8%A1%8C" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[强制] 每个独立语句结束后必须换行。</strong><br>
<strong> [强制] 运算符处换行时，运算符必须在新行的行首。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">// good
if (user.isAuthenticated()
    &amp;&amp; user.isInRole('admin')
    &amp;&amp; user.hasAuthority('add-admin')
    || user.hasAuthority('delete-admin')
) {
    // Code
}

var result = number1 + number2 + number3 + number4 + number5;

// bad
if (user.isAuthenticated() &amp;&amp;
user.isInRole('admin') &amp;&amp;
user.hasAuthority('add-admin') ||
user.hasAuthority('delete-admin')) {
// Code
}

var result = number1 + number2 + number3 +
number4 + number5;

</pre><p>
<strong>[强制] 在函数声明、函数表达式、函数调用、对象创建、数组创建、for语句等场景中，不允许在&nbsp;,&nbsp;或&nbsp;;&nbsp;前换行。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">// good
var obj = {
    a: 1,
    b: 2,
    c: 3
};

foo(
aVeryVeryLongArgument,
anotherVeryLongArgument,
callback
);

// bad
var obj = {
a: 1
, b: 2
, c: 3
};

foo(
aVeryVeryLongArgument
, anotherVeryLongArgument
, callback
);

</pre><p>
<strong> [建议] 在语句的行长度超过&nbsp;120&nbsp;时，根据逻辑条件合理缩进。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">// 较复杂的逻辑条件组合，将每个条件独立一行，逻辑运算符放置在行首进行分隔，或将部分逻辑按逻辑组合进行分隔。
// 建议最终将右括号 ) 与左大括号 { 放在独立一行，保证与 if 内语句块能容易视觉辨识。
if (user.isAuthenticated()
    &amp;&amp; user.isInRole('admin')
    &amp;&amp; user.hasAuthority('add-admin')
    || user.hasAuthority('delete-admin')
) {
    // Code
}

// 按一定长度截断字符串，并使用 + 运算符进行连接。
// 分隔字符串尽量按语义进行，如不要在一个完整的名词中间断开。
// 特别的，对于 HTML 片段的拼接，通过缩进，保持和 HTML 相同的结构。
var html = '' // 此处用一个空字符串，以便整个 HTML 片段都在新行严格对齐 + '&lt;article&gt;' + '&lt;h1&gt;Title here&lt;/h1&gt;' + '&lt;p&gt;This is a paragraph&lt;/p&gt;' + '&lt;footer&gt;Complete&lt;/footer&gt;' + '&lt;/article&gt;';

// 也可使用数组来进行拼接，相对 + 更容易调整缩进。
var html = [
'&lt;article&gt;',
'&lt;h1&gt;Title here&lt;/h1&gt;',
'&lt;p&gt;This is a paragraph&lt;/p&gt;',
'&lt;footer&gt;Complete&lt;/footer&gt;',
'&lt;/article&gt;'
];
html = html.join('');

// 当参数过多时，将每个参数独立写在一行上，并将结束的右括号 ) 独立一行。
// 所有参数必须增加一个缩进。
foo(
aVeryVeryLongArgument,
anotherVeryLongArgument,
callback
);

// 也可以按逻辑对参数进行组合。
// 最经典的是 baidu.format 函数，调用时将参数分为“模板”和“数据”两块
baidu.format(
dateFormatTemplate,
year, month, date, hour, minute, second
);

// 当函数调用时，如果有一个或以上参数跨越多行，应当每一个参数独立一行。
// 这通常出现在匿名函数或者对象初始化等作为参数时，如 setTimeout 函数等。
setTimeout(
function () {
alert('hello');
},
200
);

order.data.read(
'id=' + me.model.id,
function (data) {
me.attchToModel(data.result);
callback();
},
300
);

// 链式调用较长时采用缩进进行调整。
$('#items')
.find('.selected')
.highlight()
.end();

// 三元运算符由 3 部分组成，因此其换行应当根据每个部分的长度不同，形成不同的情况。
var result = thisIsAVeryVeryLongCondition
? resultA : resultB;

var result = condition
? thisIsAVeryVeryLongResult
: resultB;

// 数组和对象初始化的混用，严格按照每个对象的 { 和结束 } 在独立一行的风格书写。
var array = [
{
// ...
},
{
// ...
}
];

</pre><h2 id="a1.2.4语句">1.2.4 语句<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.2.4%E8%AF%AD%E5%8F%A5" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[强制] 不得省略语句结束的分号。</strong><br>
<strong>[强制] 在&nbsp;if / else / for / do / while&nbsp;语句中，即使只有一行，也不得省略块&nbsp;{...}。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">// good
if (condition) {
    callFunc();
}

// bad
if (condition) callFunc();
if (condition)
callFunc();

</pre><p>
<strong>[强制] 函数定义结束不允许添加分号。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">// good
function funcName() {
}

// bad
function funcName() {
};

// 如果是函数表达式，分号是不允许省略的。
var funcName = function () {
};

</pre><p>
<strong>[强制]&nbsp;IIFE&nbsp;必须在函数表达式外添加&nbsp;(，非&nbsp;IIFE&nbsp;不得在函数表达式外添加&nbsp;(。</strong><br>
解释：<br>
IIFE = Immediately-Invoked Function Expression.<br>
额外的 ( 能够让代码在阅读的一开始就能判断函数是否立即被调用，进而明白接下来代码的用途。而不是一直拖到底部才恍然大悟。<br>
</p>
<p>
示例：
</p>
<pre class="wiki">// good
var task = (function () {
   // Code
   return result;
})();

var func = function () {
};

// bad
var task = function () {
// Code
return result;
}();

var func = (function () {
});

</pre><h2 id="a1.3命名">1.3 命名<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.3%E5%91%BD%E5%90%8D" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[强制]&nbsp;变量、函数、函数的&nbsp;参数、类的&nbsp;方法 / 属性、命名空间 &nbsp;使用&nbsp;Camel命名法</strong>
</p>
<p>
示例：
</p>
<pre class="wiki">var loadingModules = {};

function stringFormat(source) {
}

function hear(theBells) {
}

function TextNode(value, engine) {
this.value = value;
this.engine = engine;
}

TextNode.prototype.clone = function () {
return this;
};

equipments.heavyWeapons = {};

</pre><p>
<strong>[强制] 由多个单词组成的缩写词，在命名中，根据当前命名法和出现的位置，所有字母的大小写与首字母的大小写保持一致。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">function XMLParser() {
}

function insertHTML(element, html) {
}

var httpRequest = new HTTPRequest();

</pre><p>
<strong>[强制]&nbsp;类名&nbsp;使用&nbsp;名词。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">function Engine(options) {
}
</pre><p>
<strong>[建议]&nbsp;函数名&nbsp;使用&nbsp;动宾短语。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">function getStyle(element) {
}
</pre><p>
<strong>[建议]&nbsp;boolean&nbsp;类型的变量使用&nbsp;is&nbsp;或&nbsp;has&nbsp;开头。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">var isReady = false;
var hasMoreCommands = false;
</pre><p>
[建议]&nbsp;Promise对象&nbsp;用&nbsp;动宾短语的进行时&nbsp;表达。<br>
</p>
<p>
示例：
</p>
<pre class="wiki">var loadingData = ajax.get('url');
loadingData.then(callback);
</pre><h2 id="a1.4注释">1.4 注释<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.4%E6%B3%A8%E9%87%8A" title="链接到这一节"> ¶</a></h2>
<h2 id="a1.4.1单行注释">1.4.1 单行注释<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.4.1%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[强制] 必须独占一行。<em>&nbsp;后跟一个空格，缩进与下一行被注释说明的代码一致。</em></strong><em><br>
</em></p>
<h2 id="a1.4.2多行注释">1.4.2 多行注释<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.4.2%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[建议] 避免使用&nbsp;/*...*/&nbsp;这样的多行注释。有多行注释内容时，使用多个单行注释。</strong><br>
</p>
<h2 id="a1.4.3文档化注释">1.4.3 文档化注释<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.4.3%E6%96%87%E6%A1%A3%E5%8C%96%E6%B3%A8%E9%87%8A" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[强制] 为了便于代码阅读和自文档化，以下内容必须包含以&nbsp;/</strong>...*/&nbsp;形式的块注释中。<strong><br>
解释：<br>
1、文件<br>
2、namespace<br>
3、类<br>
4、函数或方法<br>
5、类属性<br>
6、事件<br>
7、全局变量<br>
8、常量<br>
9、AMD 模块<br>
</strong>[强制] 文档注释前必须空一行。<strong><br>
</strong>[建议] 自文档化的文档说明 what，而不是 how。<strong><br>
</strong></p>
<h2 id="a1.4.4类型定义">1.4.4 类型定义<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.4.4%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[强制] 类型定义都是以{开始, 以}结束。</strong><br>
<strong>[强制] 对于基本类型 {string}, {number}, {boolean}，首字母必须小写。</strong><br>
</p>
<h2 id="a1.4.5文件注释">1.4.5 文件注释<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.4.5%E6%96%87%E4%BB%B6%E6%B3%A8%E9%87%8A" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[强制] 文件顶部必须包含文件注释，用&nbsp;@file&nbsp;标识文件说明。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">/**
 * @file Describe the file
 */
</pre><p>
<strong>[建议] 文件注释中可以用&nbsp;@author&nbsp;标识开发者信息。</strong><br>
解释：<br>
开发者信息能够体现开发人员对文件的贡献，并且能够让遇到问题或希望了解相关信息的人找到维护人。通常情况文件在被创建时标识的是创建者。随着项目的进展，越来越多的人加入，参与这个文件的开发，新的作者应该被加入&nbsp;@author&nbsp;标识。<br>
@author&nbsp;标识具有多人时，原则是按照&nbsp;责任&nbsp;进行排序。通常的说就是如果有问题，就是找第一个人应该比找第二个人有效。比如文件的创建者由于各种原因，模块移交给了其他人或其他团队，后来因为新增需求，其他人在新增代码时，添加&nbsp;@author标识应该把自己的名字添加在创建人的前面。
@author&nbsp;中的名字不允许被删除。任何劳动成果都应该被尊重。<br>
业务项目中，一个文件可能被多人频繁修改，并且每个人的维护时间都可能不会很长，不建议为文件增加&nbsp;@author&nbsp;标识。通过版本控制系统追踪变更，按业务逻辑单元确定模块的维护责任人，通过文档与wiki跟踪和查询，是更好的责任管理方式。
对于业务逻辑无关的技术型基础项目，特别是开源的公共项目，应使用&nbsp;@author&nbsp;标识。<br>
示例：
</p>
<pre class="wiki">/**
 * @file Describe the file
 * @author author-name
 *         author-name2
 */
</pre><h2 id="a1.4.6函数方法注释">1.4.6 函数/方法注释<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.4.6%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95%E6%B3%A8%E9%87%8A" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[强制] 函数/方法注释必须包含函数说明，有参数和返回值时必须使用注释标识。</strong><br>
<strong>[强制] 参数和返回值注释必须包含类型信息和说明。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">/**
 * 函数描述
 *
 * @param {string} p1 参数1的说明
 * @param {string} p2 参数2的说明，比较长
 *     那就换行了.
 * @param {number=} p3 参数3的说明（可选）
 * @return {Object} 返回值描述
 */
function foo(p1, p2, p3) {
    var p3 = p3 || 10;
    return {
        p1: p1,
        p2: p2,
        p3: p3
    };
}
</pre><p>
<strong>[强制] 对 Object 中各项的描述， 必须使用&nbsp;@param&nbsp;标识。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">/**
 * 函数描述
 *
 * @param {Object} option 参数描述
 * @param {string} option.url option项描述
 * @param {string=} option.method option项描述，可选参数
 */
function foo(option) {
    // TODO
}
</pre><h2 id="a1.4.7事件注释">1.4.7 事件注释<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.4.7%E4%BA%8B%E4%BB%B6%E6%B3%A8%E9%87%8A" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[强制] 必须使用&nbsp;@event&nbsp;标识事件，事件参数的标识与方法描述的参数标识相同。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">/**
 * 值变更时触发
 *
 * @event
 * @param {Object} e e描述
 * @param {string} e.before before描述
 * @param {string} e.after after描述
 */
onchange: function (e) {
}
</pre><h2 id="a1.4.8细节注释">1.4.8 细节注释<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a1.4.8%E7%BB%86%E8%8A%82%E6%B3%A8%E9%87%8A" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[建议] 细节注释遵循单行注释的格式。说明必须换行时，每行是一个单行注释的起始。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">function foo(p1, p2, opt_p3) {
    // 这里对具体内部逻辑进行说明
    // 说明太长需要换行
    for (...) {
        ....
    }
}
</pre><p>
<strong>[强制] 有时我们会使用一些特殊标记进行说明。特殊标记必须使用单行注释的形式。下面列举了一些常用标记：</strong><br>
解释：<br>
1、TODO: 有功能待实现。此时需要对将要实现的功能进行简单说明。<br>
2、FIXME: 该处代码运行没问题，但可能由于时间赶或者其他原因，需要修正。此时需要对如何修正进行简单说明。<br>
3、HACK: 为修正某些问题而写的不太好或者使用了某些诡异手段的代码。此时需要对思路或诡异手段进行描述。<br>
4、XXX: 该处存在陷阱。此时需要对陷阱进行描述。<br>
</p>
<h2 id="a2语言特性">2 语言特性<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7" title="链接到这一节"> ¶</a></h2>
<h2 id="a2.1变量">2.1 变量<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.1%E5%8F%98%E9%87%8F" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[强制] 变量在使用前必须定义。 （在.jsx中我们用let, .ftl中我们用var）。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">// good
let name = 'MyName';

// bad
name = 'MyName';

</pre><p>
<strong>[强制] 每个&nbsp;var / let&nbsp;只能声明一个变量。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">// good
let hangModules = [];
let missModules = [];
let visited = {};

// bad
let hangModules = [],
missModules = [],
visited = {};

</pre><p>
<strong>[强制] 变量必须&nbsp;即用即声明，不得在函数或其它形式的代码块起始位置统一声明所有变量。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">// good
function kv2List(source) {
    let list = [];

    for (let key in source) {
        if (source.hasOwnProperty(key)) {
            let item = {
                k: key,
                v: source[key]
            };
            list.push(item);
        }
    }

    return list;

}

// bad
function kv2List(source) {
let list = [];
let key;
let item;

    for (key in source) {
        if (source.hasOwnProperty(key)) {
            item = {
                k: key,
                v: source[key]
            };
            list.push(item);
        }
    }

    return list;

}

</pre><h2 id="a2.2条件">2.2 条件<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.2%E6%9D%A1%E4%BB%B6" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[强制] 在 Equality Expression 中使用类型严格的&nbsp;===。仅当判断 null 或 undefined 时，允许使用&nbsp;== null。</strong><br>
解释：<br>
使用 === 可以避免等于判断中隐式的类型转换。<br>
</p>
<p>
示例：
</p>
<pre class="wiki">// good
if (age === 30) {
    // ......
}

// bad
if (age == 30) {
// ......
}

</pre><p>
<strong>[建议] 尽可能使用简洁的表达式。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">// 字符串为空

// good
if (!name) {
// ......
}

// bad
if (name === '') {
// ......
}
// 字符串非空

// good
if (name) {
// ......
}

// bad
if (name !== '') {
// ......
}
// 数组非空

// good
if (collection.length) {
// ......
}

// bad
if (collection.length &gt; 0) {
// ......
}
// 布尔不成立

// good
if (!notTrue) {
// ......
}

// bad
if (notTrue === false) {
// ......
}
// null 或 undefined

// good
if (noValue == null) {
// ......
}

// bad
if (noValue === null || typeof noValue === 'undefined') {
// ......
}

</pre><p>
<strong>[建议] 对于相同变量或表达式的多值条件，用&nbsp;switch&nbsp;代替&nbsp;if。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">// good
switch (typeof variable) {
    case 'object':
        // ......
        break;
    case 'number':
    case 'boolean':
    case 'string':
        // ......
        break;
}

// bad
let type = typeof variable;
if (type === 'object') {
// ......
}
else if (type === 'number' || type === 'boolean' || type === 'string') {
// ......
}

</pre><h2 id="a2.3循环">2.3 循环<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.3%E5%BE%AA%E7%8E%AF" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[建议] 不要在循环体中包含函数表达式，事先将函数提取到循环体外。</strong><br>
解释：<br>
循环体中的函数表达式，运行过程中会生成循环次数个函数对象。<br>
</p>
<p>
示例:
</p>
<pre class="wiki">// good
function clicker() {
    // ......
}

for (let i = 0, len = elements.length; i &lt; len; i++) {
let element = elements[i];
addListener(element, 'click', clicker);
}

// bad
for (let i = 0, len = elements.length; i &lt; len; i++) {
let element = elements[i];
addListener(element, 'click', function () {});
}

</pre><p>
<strong>[建议] 对循环内多次使用的不变值，在循环外用变量缓存。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">// good
let width = wrap.offsetWidth + 'px';
for (let i = 0, len = elements.length; i &lt; len; i++) {
    let element = elements[i];
    element.style.width = width;
    // ......
}

// bad
for (let i = 0, len = elements.length; i &lt; len; i++) {
var element = elements[i];
element.style.width = wrap.offsetWidth + 'px';
// ......
}

</pre><p>
<strong>[建议] 对有序集合进行遍历时，缓存&nbsp;length。</strong><br>
解释：<br>
虽然现代浏览器都对数组长度进行了缓存，但对于一些宿主对象和老旧浏览器的数组对象，在每次 length 访问时会动态计算元素个数，此时缓存 length 能有效提高程序性能。<br>
</p>
<p>
示例：
</p>
<pre class="wiki">for (let i = 0, len = elements.length; i &lt; len; i++) {
    let element = elements[i];
    // ......
}
</pre><p>
<strong>[建议] 对有序集合进行顺序无关的遍历时，使用逆序遍历。</strong><br>
解释：<br>
逆序遍历可以节省变量，代码比较优化。<br>
</p>
<p>
示例：
</p>
<pre class="wiki">let len = elements.length;
while (len--) {
    let element = elements[len];
    // ......
}
</pre><h2 id="a2.4类型">2.4 类型<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.4%E7%B1%BB%E5%9E%8B" title="链接到这一节"> ¶</a></h2>
<h2 id="a2.4.1类型检测">2.4.1 类型检测<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.4.1%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[建议] 类型检测优先使用&nbsp;typeof。对象类型检测使用&nbsp;instanceof。null&nbsp;或&nbsp;undefined&nbsp;的检测使用&nbsp;== null。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">// string
typeof variable === 'string'

// number
typeof variable === 'number'

// boolean
typeof variable === 'boolean'

// Function
typeof variable === 'function'

// Object
typeof variable === 'object'

// RegExp
variable instanceof RegExp

// Array
variable instanceof Array

// null
variable === null

// null or undefined
variable == null

// undefined
typeof variable === 'undefined'

</pre><h2 id="a2.4.2类型转换">2.4.2 类型转换<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.4.2%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[建议] 转换成&nbsp;string&nbsp;时，使用&nbsp;+ <em>。</em></strong><em><br>
</em></p>
<p>
示例：
</p>
<pre class="wiki">// good
num + '';

// bad
new String(num);
num.toString();
String(num);

</pre><p>
<strong>[建议] 转换成&nbsp;number&nbsp;时，通常使用&nbsp;+。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">// good
+str;

// bad
Number(str);

</pre><p>
<strong>[建议]&nbsp;string&nbsp;转换成&nbsp;number，要转换的字符串结尾包含非数字并期望忽略时，使用&nbsp;parseInt。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">let width = '200px';
parseInt(width, 10);
</pre><p>
<strong>[强制] 使用&nbsp;parseInt&nbsp;时，必须指定进制。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">// good
parseInt(str, 10);

// bad
parseInt(str);

</pre><p>
<strong>[建议] 转换成&nbsp;boolean&nbsp;时，使用&nbsp;!!。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">let num = 3.14;
!!num;
</pre><p>
<strong>[建议]&nbsp;number&nbsp;去除小数点，使用&nbsp;Math.floor / Math.round / Math.ceil，不使用&nbsp;parseInt。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">// good
let num = 3.14;
Math.ceil(num);

// bad
let num = 3.14;
parseInt(num, 10);

</pre><h2 id="a2.5字符串">2.5 字符串<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.5%E5%AD%97%E7%AC%A6%E4%B8%B2" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[强制] 字符串开头和结束使用单引号&nbsp;'。</strong><br>
解释：<br>
输入单引号不需要按住 shift，方便输入。<br>
实际使用中，字符串经常用来拼接 HTML。为方便 HTML 中包含双引号而不需要转义写法。<br>
</p>
<p>
示例：
</p>
<pre class="wiki">let str = '我是一个字符串';
let html = '&lt;div class="cls"&gt;拼接HTML可以省去双引号转义&lt;/div&gt;';
</pre><p>
<strong>[建议] 模板字符串进行字符串拼接</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">let str = `Hello, ${userName}!`; // username 是变量
</pre><h2 id="a2.6对象">2.6 对象<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.6%E5%AF%B9%E8%B1%A1" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[强制] 使用对象字面量&nbsp;{}&nbsp;创建新&nbsp;Object。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">// good
var obj = {};

// bad
var obj = new Object();

</pre><p>
<strong>[强制] 对象创建时，如果一个对象的所有&nbsp;属性&nbsp;均可以不添加引号，则所有&nbsp;属性&nbsp;不得添加引号。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">var info = {
    name: 'someone',
    age: 28
};

this.setState({
name: 'someone',
age: 28
});

</pre><p>
<strong>[强制] 对象创建时，如果任何一个&nbsp;属性&nbsp;需要添加引号，则所有&nbsp;属性&nbsp;必须添加&nbsp;'。</strong><br>
解释：<br>
如果属性不符合 Identifier 和 <a class="missing wiki" href="http://10.1.0.6/trac/LabwayLIMS/wiki/NumberLiteral" rel="nofollow">NumberLiteral?</a> 的形式，就需要以 <a class="missing wiki" href="http://10.1.0.6/trac/LabwayLIMS/wiki/StringLiteral" rel="nofollow">StringLiteral?</a> 的形式提供。<br>
</p>
<p>
示例：
</p>
<pre class="wiki">// good
var info = {
    'name': 'someone',
    'age': 28,
    'more-info': '...'
};

// bad
var info = {
name: 'someone',
age: 28,
'more-info': '...'
};

</pre><p>
<strong>[建议] 属性访问时，尽量使用&nbsp;.。</strong><br>
解释：用&nbsp;.&nbsp;来访问更清晰简洁。部分特殊的属性(比如来自后端的JSON)，可能采用不寻常的命名方式，可以通过&nbsp;[expr]&nbsp;方式访问。<br>
</p>
<p>
示例：
</p>
<pre class="wiki">info.age;
info['more-info'];
</pre><p>
<strong>[建议]&nbsp;for in&nbsp;遍历对象时, 使用&nbsp;hasOwnProperty&nbsp;过滤掉原型中的属性。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">var newInfo = {};
for (var key in info) {
    if (info.hasOwnProperty(key)) {
        newInfo[key] = info[key];
    }
}
</pre><h2 id="a2.7数组">2.7 数组<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.7%E6%95%B0%E7%BB%84" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[强制] 使用数组字面量&nbsp;[]&nbsp;创建新数组，除非想要创建的是指定长度的数组。</strong><br>
</p>
<p>
示例：
</p>
<pre class="wiki">// good
var arr = [];

// bad
var arr = new Array();

</pre><h2 id="a2.8函数">2.8 函数<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.8%E5%87%BD%E6%95%B0" title="链接到这一节"> ¶</a></h2>
<h2 id="a2.8.1函数长度">2.8.1 函数长度<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.8.1%E5%87%BD%E6%95%B0%E9%95%BF%E5%BA%A6" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[建议] 一个函数的长度控制在&nbsp;50&nbsp;行以内。</strong><br>
解释：<br>
将过多的逻辑单元混在一个大函数中，易导致难以维护。一个清晰易懂的函数应该完成单一的逻辑单元。复杂的操作应进一步抽取，通过函数的调用来体现流程。<br>
特定算法等不可分割的逻辑允许例外。<br>
</p>
<p>
示例：
</p>
<pre class="wiki">function syncViewStateOnUserAction() {
    if (x.checked) {
        y.checked = true;
        z.value = '';
    }
    else {
        y.checked = false;
    }

    if (!a.value) {
        warning.innerText = 'Please enter it';
        submitButton.disabled = true;
    }
    else {
        warning.innerText = '';
        submitButton.disabled = false;
    }

}
// 直接阅读该函数会难以明确其主线逻辑，因此下方是一种更合理的表达方式：

function syncViewStateOnUserAction() {
syncXStateToView();
checkAAvailability();
}

function syncXStateToView() {
if (x.checked) {
y.checked = true;
z.value = '';
}
else {
y.checked = false;
}
}

function checkAAvailability() {
if (!a.value) {
displayWarningForAMissing();
}
else {
clearWarnignForA();
}
}

</pre><h2 id="a2.8.2参数设计">2.8.2 参数设计<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.8.2%E5%8F%82%E6%95%B0%E8%AE%BE%E8%AE%A1" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[建议] 通过&nbsp;options&nbsp;参数传递非数据输入型参数。</strong><br>
解释：<br>
有些函数的参数并不是作为算法的输入，而是对算法的某些分支条件判断之用，此类参数建议通过一个 options 参数传递。<br>
如下函数：
</p>
<pre class="wiki">/**
 * 移除某个元素
 *
 * @param {Node} element 需要移除的元素
 * @param {boolean} removeEventListeners 是否同时将所有注册在元素上的事件移除
 */
function removeElement(element, removeEventListeners) {
    element.parent.removeChild(element);
    if (removeEventListeners) {
        element.clearEventListeners();
    }
}
</pre><p>
可以转换为下面的签名：
</p>
<pre class="wiki">/**
 * 移除某个元素
 *
 * @param {Node} element 需要移除的元素
 * @param {Object} options 相关的逻辑配置
 * @param {boolean} options.removeEventListeners 是否同时将所有注册在元素上的事件移除
 */
function removeElement(element, options) {
    element.parent.removeChild(element);
    if (options.removeEventListeners) {
        element.clearEventListeners();
    }
}
</pre><p>
这种模式有几个显著的优势：
</p>
<ul><li>boolean 型的配置项具备名称，从调用的代码上更易理解其表达的逻辑意义。
</li><li>当配置项有增长时，无需无休止地增加参数个数，不会出现 removeElement(element, true, false, false, 3) 这样难以理解的调用代码。
</li><li>当部分配置参数可选时，多个参数的形式非常难处理重载逻辑，而使用一个 options 对象只需判断属性是否存在，实现得以简化。
</li></ul><h2 id="a2.8.3闭包">2.8.3 闭包<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.8.3%E9%97%AD%E5%8C%85" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[建议] 在适当的时候将闭包内大对象置为&nbsp;null。</strong><br>
解释：如果有&nbsp;非常庞大&nbsp;的对象，且预计会在&nbsp;老旧的引擎&nbsp;中执行，则使用闭包时，注意将闭包不需要的对象置为空引用。<br>
<strong>[建议] 使用&nbsp;IIFE&nbsp;避免&nbsp;Lift 效应。</strong><br>
解释：<br>
在引用函数外部变量时，函数执行时外部变量的值由运行时决定而非定义时，最典型的场景如下：
</p>
<pre class="wiki">var tasks = [];
for (var i = 0; i &lt; 5; i++) {
    tasks[tasks.length] = function () {
        console.log('Current cursor is at ' + i);
    };
}

var len = tasks.length;
while (len--) {
tasks[len]();
}

</pre><p>
以上代码对 tasks 中的函数的执行均会输出&nbsp;Current cursor is at 5，往往不符合预期。<br>
此现象称为&nbsp;Lift 效应&nbsp;。解决的方式是通过额外加上一层闭包函数，将需要的外部变量作为参数传递来解除变量的绑定关系：
</p>
<pre class="wiki">var tasks = [];
for (var i = 0; i &lt; 5; i++) {
    // 注意有一层额外的闭包
    tasks[tasks.length] = (function (i) {
        return function () {
            console.log('Current cursor is at ' + i);
        };
    })(i);
}

var len = tasks.length;
while (len--) {
tasks[len]();
}

</pre><h2 id="a2.9面向对象">2.9 面向对象<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.9%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[强制] 自定义事件的&nbsp;事件名&nbsp;必须全小写。</strong>
<strong>[强制] 自定义事件只能有一个&nbsp;event&nbsp;参数。如果事件需要传递较多信息，应仔细设计事件对象。</strong>
<strong>[建议] 设计自定义事件时，应考虑禁止默认行为。</strong>
</p>
<h2 id="a2.10动态特性">2.10 动态特性<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.10%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7" title="链接到这一节"> ¶</a></h2>
<h2 id="a2.10.1delete">2.10.1 delete<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.10.1delete" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[建议] 减少&nbsp;delete&nbsp;的使用。</strong>
解释：<br>
如果没有特别的需求，减少或避免使用delete。delete的使用会破坏部分 <a class="missing wiki" href="http://10.1.0.6/trac/LabwayLIMS/wiki/JavaScript" rel="nofollow">JavaScript?</a> 引擎的性能优化。<br>
<strong>[建议] 处理&nbsp;delete&nbsp;可能产生的异常。</strong><br>
解释：<br>
对于有被遍历需求，且值 null 被认为具有业务逻辑意义的值的对象，移除某个属性必须使用 delete 操作。<br>
在严格模式或IE下使用 delete 时，不能被删除的属性会抛出异常，因此在不确定属性是否可以删除的情况下，建议添加 try-catch 块。<br>
</p>
<p>
示例：
</p>
<pre class="wiki">try {
    delete o.x;
}
catch (deleteError) {
    o.x = null;
}
</pre><h2 id="a2.10.2对象属性">2.10.2 对象属性<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a2.10.2%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[建议] 避免修改外部传入的对象。</strong><br>
解释：<br>
<a class="missing wiki" href="http://10.1.0.6/trac/LabwayLIMS/wiki/JavaScript" rel="nofollow">JavaScript?</a> 因其脚本语言的动态特性，当一个对象未被 seal 或 freeze 时，可以任意添加、删除、修改属性值。<br>
但是随意地对 非自身控制的对象 进行修改，很容易造成代码在不可预知的情况下出现问题。因此，设计良好的组件、函数应该避免对外部传入的对象的修改。<br>
下面代码的 selectNode 方法修改了由外部传入的 datasource 对象。如果 datasource 用在其它场合（如另一个 Tree 实例）下，会造成状态的混乱。<br>
</p>
<pre class="wiki">function Tree(datasource) {
    this.datasource = datasource;
}

Tree.prototype.selectNode = function (id) {
// 从 datasource 中找出节点对象
var node = this.findNode(id);
if (node) {
node.selected = true;
this.flushView();
}
};

</pre><p>
对于此类场景，需要使用额外的对象来维护，使用由自身控制，不与外部产生任何交互的 selectedNodeIndex 对象来维护节点的选中状态，不对 datasource 作任何修改。
</p>
<pre class="wiki">function Tree(datasource) {
    this.datasource = datasource;
    this.selectedNodeIndex = {};
}

Tree.prototype.selectNode = function (id) {
// 从 datasource 中找出节点对象
var node = this.findNode(id);
if (node) {
this.selectedNodeIndex[id] = true;
this.flushView();
}
};

</pre><p>
除此之外，也可以通过 deepClone 等手段将自身维护的对象与外部传入的分离，保证不会相互影响。
</p>
<h2 id="a3浏览器环境">3 浏览器环境<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83" title="链接到这一节"> ¶</a></h2>
<h2 id="a3.1DOM">3.1 DOM<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a3.1DOM" title="链接到这一节"> ¶</a></h2>
<h2 id="a3.1.1元素获取">3.1.1 元素获取<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a3.1.1%E5%85%83%E7%B4%A0%E8%8E%B7%E5%8F%96" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[建议] 对于单个元素，尽可能使用&nbsp;document.getElementById&nbsp;获取，避免使用document.all。</strong><br>
<strong>[建议] 对于多个元素的集合，尽可能使用&nbsp;context.getElementsByTagName&nbsp;获取。其中&nbsp;context&nbsp;可以为&nbsp;document&nbsp;或其他元素。指定&nbsp;tagName&nbsp;参数为&nbsp;*&nbsp;可以获得所有子元素。</strong><br>
<strong>[建议] 遍历元素集合时，尽量缓存集合长度。如需多次操作同一集合，则应将集合转为数组。</strong><br>
</p>
<h2 id="a3.1.2样式获取">3.1.2 样式获取<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a3.1.2%E6%A0%B7%E5%BC%8F%E8%8E%B7%E5%8F%96" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[建议] 获取元素实际样式信息时，应使用&nbsp;getComputedStyle&nbsp;或&nbsp;currentStyle。</strong><br>
</p>
<h2 id="a3.1.3样式设置">3.1.3 样式设置<a class="anchor" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention#a3.1.3%E6%A0%B7%E5%BC%8F%E8%AE%BE%E7%BD%AE" title="链接到这一节"> ¶</a></h2>
<p>
<strong>[建议] 尽可能通过为元素添加预定义的 className 来改变元素样式，避免直接操作 style 设置。</strong><br>
</p>
</div>
          
          <div class="trac-modifiedby">
            <span><a href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention?action=diff&amp;version=8" title="版本 8 来自 王茹">Last modified</a> <a class="timeline" href="http://10.1.0.6/trac/LabwayLIMS/timeline?from=2019-03-14T16%3A31%3A59%2B08%3A00&amp;precision=second" title="See timeline at 2019年3月14日 下午4:31:59">3年 ago</a></span>
            <span class="trac-print">Last modified on 2019年3月14日 下午4:31:59</span>
          </div>
        
        
      </div>
      
    <div id="attachments">
    </div>

          <div class="buttons">
              <form method="get" action="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention" id="modifypage">
                <div>
                  <input type="hidden" name="action" value="edit">
                      <input type="submit" value="编辑此页面">
                </div>
              </form>
                <form method="get" action="http://10.1.0.6/trac/LabwayLIMS/attachment/wiki/FrontendNameConvention/" id="attachfile">

  <div>
    <input type="hidden" name="action" value="new">
    <input type="submit" id="attachfilebutton" value="附加文件">
  </div>
</form>
          </div>
    </div>
    <div id="altlinks">
      <h3>用其他格式下载:</h3>
      <ul>
        <li class="last first">
          <a rel="nofollow" href="http://10.1.0.6/trac/LabwayLIMS/wiki/FrontendNameConvention?format=txt">纯文本</a>
        </li>
      </ul>
    </div>
    </div>
    <div id="footer" lang="en" xml:lang="en"><hr>
      <a id="tracpowered" href="https://trac.edgewall.org/"><img src="./FrontendNameConvention – Labway LIMS_files/trac_logo_mini.png" height="30" width="107" alt="Trac Powered"></a>
      <p class="left">由 <a href="http://www.edgewall.org/">Edgewall Software</a> 的 <a href="http://10.1.0.6/trac/LabwayLIMS/about"><strong>Trac 1.2.6</strong></a><br>
        提供动力</p>
      <p class="right">请访问Trac开源项目<br><a href="http://trac.edgewall.org/">http://trac.edgewall.org/</a></p>
    </div>
  
</body></html>
